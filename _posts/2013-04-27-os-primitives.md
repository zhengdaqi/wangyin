---
layout: default
title: 谈操作系统的原语
published: false
---


有一次 Cornell 操作系统考试，出了这么一道题：一条河的两边各有5只猴子要过河。可是河上只有一根绳子，猴子需要攀着绳子过河。如果两只猴子在绳子中间遇上了，就会掉进河里。请你使用 semaphore 写出一个程序，让这些猴子都可以安全过河。

我的答案是：让这些猴子先去“拿号”，被叫到号码的猴子挨个过河。可是没想到这么喜欢排队的美国人，居然觉得我的答案是错的，就因为我没用 semaphore。

操作系统的课程和书籍往往有很多类似的“同步”问题。对于这些问题，往往有人给你一个“标准答案”，却从来不告诉你这标准答案是怎么想出来的。谁也不知道如何才能“系统的”（systematically），按部就班的得到这些问题的答案。这些问题的“标准答案”里面往往含有一些“聪明技巧”，貌似天上掉下来的。然而，你却很难相信它们是正确的。证明这些答案的正确性，到现在还是研究性质的问题。所以有时候你绞尽脑汁用 semaphore 这样的东西写出来一个程序，试了好多个例子貌似都是对的，结果最后实际运行的时候就出问题。

我觉得这里的问题在于，这些操作系统的“原语”（比如 semaphore） 本来是被“发明”出来解决某个“特定”的问题，而并不是本质上“通用”的东西。对于当时要解决的那一个问题，它也许是很有效的。可是接下来它就被滥用了，被用在了设计者没有考虑过的地方。当然，你就遇到各种麻烦的问题，比如“竞争”，“死锁”。试图使用你的聪明才智利用它们来解决问题，只不过是一些 workaround 而已。其实很多专家级的人物用这些东西的时候心里都在打鼓，不知道到时候会不会出问题。这样的现象，往往意味着你使用了错误的工具。

这就像很多人在 C 程序里写 macro 用来代替“重复的代码”。在某个程序里这个 macro 也许是有效的。可是接下来它就被滥用了。人们看不到，其实被这个 macro “组合”起来的那些操作如果被分开来用，会让程序更加直接的达到目的。然而写出了这个 macro 之后，有人就开始错误的认为这些被它所压缩在一起的操作是一个“原语”，从而不假思索的开始“重用”它。这个错误跟 semaphore 被到处滥用的现象本质是一样的。


计算机科学里面遇到的很多难题，其实都是来自于同一个错误：使用错误的工具，解决错误的问题。所以遇到任何这些问题，我们都应该多问几个“为什么”。找准了问题的源头，才能得到最有效的解决方案。
