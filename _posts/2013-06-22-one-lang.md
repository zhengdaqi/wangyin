---
layout: default
title: “One语言”的设计理念
---


### 前言

上文提到我下一篇博客要讲静态分析的原理，但是睡了一晚上之后，觉得更有动力先讲一下我的语言的设计，以后再讲静态分析的事情。当然这篇文章里面也会涉及到静态分析的一些东西。以后我应该尽量避免谈到“下一篇博客”要讲什么，因为我总是喜欢改变主意。

我考虑了一下用什么语言来写这篇文章。因为显然我想让全世界的人都用它，所以我貌似应该用英语。但是从我在美国的经历，以及跟我讨论问题的中国人的水平来看，很多中国人对于计算机科学和编程语言的理解程度一点也不亚于美国人。由于几千年来千奇百怪的历史政治事件，导致了中国人对事物持有更多的怀疑。这不是坏事，因为怀疑的态度让中国人不容易拘泥于旧的思维方式，思想更加开放，容易接受新的东西。我真心的希望自己的国家能够变得更好，所以我觉得我应该给中文一些优先，这样新的信息首先被中国人知道。这么想不是因为我“大公无私”，而是因为只有中国变得强大，全世界的中国人才抬得起头来，不然全世界的中国人，不管生活在哪里都会被欺负。真的，这是我的切身体会。


### 开始

其实我一直在设计一种语言。从进入 Cornell 之后，我就在搜集各种资料信息，想设计一种“终极语言”，它会使得编程变得极其简单。因为大家都用这同一种语言，所以不管是人还是程序间的信息交换都会变得非常容易。软件的构造效率会大幅度提高。

我把这种语言暂时称为 One。如果写一本书，就应该叫：The One Programming Language。THE ONE — 让我想起了骇客帝国的 Neo…… 也许可以把用这个语言写出来的操作系统叫做 Neo。一种用于取代 Unix 的操作系统，就是我的下一个目标。实际上这个操作系统，就是 One 语言的“运行时系统”（runtime）。


### 为什么我们只需要一种程序语言

有些人认为只用一种程序语言貌似天方夜谭的事情，然而我觉得这是有可能实现的。

很多人从自然语言的现状出发，觉得世界上需要多种程序语言。然而圣经的故事告诉我们，在最早的时候全世界只有一种语言。但是由于全部人都用这种语言，信息交互非常迅速，人类发展很快。上帝开始担心人会超越自己，所以就施了一个法术，让不同地方的人开始说不同的语言。这样人们由于信息交互不流畅，发展就减慢了。当然圣经只是一本故事书，但这貌似仍然说明了一些问题。

从认知科学的角度来看，人类其实根本不是用自然语言思考的，不管是中文还是英语，法语…… 不同国家的人在思考的时候，脑子里其实运行的是同一种没有名字的“人脑语言”。他们需要交流的时候，才会把这些模型转换为自然语言。这种“人脑语言”构造出现实世界的一个“模型”（model）。人脑通过对这种模型进行“模拟”，从而能够预见短暂的未来，对将要发生的事情提前做好安排。程序语言其实就跟人脑里面的这种语言类似，它也是一种用于构造“模型”的材料，这种模型不是由人脑，而是由电脑来模拟运行。这就是为什么我们能用电脑来预报天气。

从物理的角度来看，我们生活的世界本来就是由非常简单的材料——基本粒子构成的。我们看到的千奇百怪的物体，不过都是这些基本粒子经过不同的组合方式放在一起而已。所以有什么理由认为我们需要很多种程序语言呢？

所以，我觉得世界上根本不需要那么多种程序语言。理想的情况是一种就够了。


### One语言的基本要素

One语言的设计融合了很多种语言的因素和一些新的想法。它并不是简单的把它们放在一起，而是从哲学的角度出发，让这些要素天衣无缝的组合在一起。需要描述的每一个模型，都有一个最直接，最高效的描述方式，而不需要转几道弯，绕过一堆语言设计的无端限制来完成。

我现在就介绍一下几个最主要的要素。偏向于某些语言的人也许会对我的选择比较吃惊，但是我会对这些选择做出简要的分析，说明我的理由，或者给出之前的一些博文的链接。


#### 语法

One 语言使用与 Lisp/Scheme 类似的，基于“S表达式”的语法，但比它们的“语法”含量还要少，还要简单。比如，它不包含 #(...) 这样的东西。通常所谓的“S表达式”其实包含了不少的复杂性，这使得“reader”（也就是 Lisp 的 parser）的构造其实并不像传说中的那么简单。这样的选择的目的，在于让语法分析变得极其容易，速度极快。再加上编译器速度也快，“编译加运行”的过程里面，“编译”占的比重非常之小。所以开发程序的时候你可以专注于源程序，而不必担心“build”的过程。

这样的语法会在早期带来一定的“打字开销”，但是从长远角度来看是有益处的。以为我的设想中，Neo 系统会自带一种基于“结构化编辑”的 IDE，它能够帮助高效的编辑 One 语言的源文件，也可以让人可以选择更加美观的“渲染”方式。

在这种 IDE 实现以前，也可以用 Emacs 加 <a href="http://mumble.net/~campbell/emacs/paredit.el">paredit-mode.el</a>。由于 One 语言实现考虑到了这一点，所以编译器会给 IDE 提供相当大的支持，使得 IDE 的实现变得异常容易。

关于语法，详细的思想可以参考之前一篇博文：《<a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">谈语法</a>》。


#### 函数式

One 语言具有 first-class function。函数可以作为值任意传递。跟 Scheme 一样，这是一种真正的 lambda。很多语言虽然有叫 lambda 的东西，但却不能正确的实现，比如 Python 和 C++11。关于这个我现在就不多说了。


#### 副作用

One 语言不是一种“纯函数式”语言，它允许自由的使用副作用。为什么不设计成像 Haskell 那样的纯函数式语言，不但是出于效率的需求，而且是因为“纯函数式”本身的问题。纯函数式语言所能表达的一切对于“安全性”的要求，其实都可以通过简单的静态分析来达到。实际上，静态分析系统的实现，里面就有很多类似 monads 的东西。纯函数式语言带来了程序员的各种麻烦，因为它相当于让程序员自己在实现一些简单的静态分析系统。关于这个问题，可以参考另一篇博文：《<a href="http://www.yinwang.org/blog-cn/2013/03/31/purely-functional">对函数式语言的误解</a>》。

纯函数式（或者叫 persistent）的数据结构，其实在效率上也有根本性的问题，这个问题并不是像有些人说的“因为现有的硬件是针对副作用来设计的”，而是从拓扑学的角度多了很多层“间接”（indirection）关系，所以它的效率问题是根本性，算法性的。很多通过一个简单的赋值就能做到的事情，纯函数式的写法得绕很多弯子，而且效率还低。

所以 One 语言允许使用各种副作用和赋值。当然，真的需要纯函数式数据结构的时候，你也可以实现它们，你只要不用赋值语句就可以。


#### 没有 let (暂行）

跟 Lisp 和 Scheme 不同，对于变量的“绑定”不使用 let，而是采用像普通语言里的变量声明。在 Lisp 里的

    (let ([x 1])
      ...)

变成了变量声明（语法是暂时的设计，重用类型声明的语法，看是否能把它们“统一”起来）：

    (: x 1)
    ...

去掉 let 的原因是，let 往往形成不必要的嵌套和缩进，然而从“模型”的角度，它跟赋值语句是一样的效果：它们都描述的是一根“电线”，也就是数据通路。另外 let 和 if 一起，经常产生一些复杂难读的结构，比如，

    (let ([x (if y 0 1)]) ...)

你必须把 (if y 0 1) 嵌套在 let 之内才能让同一个变量依据不同的条件得到不同的值。可是如果你有变量声明和赋值语句，你就可以写：

    (: x)
    (if y
      (<- x 0)
      (<- x 1))

赋值语句只能对已经“绑定”的变量进行赋值，而不能构造新的绑定。声明和赋值都不需要类型标记，系统会很容易的自动推导出类型。


#### 不区分stack和heap变量

跟 C++ 和 C# 不同，但是跟 Scheme 和 Java 类似， 所有的变量都只是一个名字，程序员没必要知道它被放在堆栈（stack）上还是堆（heap）上。做这样的选择是为了让“名字”这个概念更加有一致性。为什么程序员需要知道它在哪里呢？这种事情本来就应该是编译器来做的。程序员所要知道的只是“一个名字对应一个对象”。


#### 快速而高效的寄存器分配算法

很多编译器都使用一种图着色的寄存器分配算法，这种算法的复杂度是 NP-Complete 的，就算近似解的复杂度也不能达到线性时间。

经过一个学期与 Kent Dybvig 的 independent study，我设计了一个与 Chez Scheme 类似，却又在某些地方应该更加高效的算法。这个算法极其简单，但却可以达到超过图着色算法的效果。它其实自然的包含了 linear scan 和 live range splitting 两种技术的组合。原理是把寄存器作为堆栈的“cache”，这样寄存器的分配就变成了一个静态的“cache replacement”算法。

这个方法被记录与我写的（Kent挂名）的一篇 paper 稿（未发表）。你可以在这里看到它的全文。

<a href="http://arxiv.org/abs/1202.5539">http://arxiv.org/abs/1202.5539</a>


#### 自动的，非 GC 实时内存管理

由于 One 语言必须能够被应用于实时系统，所以我不考虑使用垃圾回收（GC）。在目前来看，再好的垃圾回收算法也是不能完全保证实时回收内存的。引起程序的暂停情况，在很多情况下是不可接受的。这不只是在实时的控制系统（比如飞机，导弹，汽车等），而且在现在的高度发达的互联网上，GC 带来的停顿也会引起问题，这就是为什么我听说淘宝和 Twitter 都试图改进 JVM 的 GC。Chez Scheme 使用了 generational GC，总共有5个 generation。据说效率相当高，可是我仍然怀疑它是否能达到最高的实时系统标准，因为貌似没有实时系统在使用 Chez Scheme。

GC 的问题就是为什么 C++ 继续流行的原因。我觉得与其解决这个问题，带来 runtime 的复杂性，不如使用另外的方式。其实我早就设计出了一种自动的引用计数的方式，但是我一直有点怀疑它的效率会受到引用计数变化的影响。利用一定的指针分析（pointer analysis），我可以降低一部分这种开销。只有必须被放在堆上的数据，才会被引用技术。编译器会通过 escape analysis，自动把没法“逃脱”(escape）堆栈作用域的数据都作为堆栈数据处理，剩下的才放在 heap 上。只有放在 heap 上的对象才需要被引用计数。放在堆栈上的对象会在函数结束时被回收。

对于引用计数里面的 cycle 问题，我决定依靠程序员自己做记号来实现。如果他需要指出“我现在的赋值语句会在数据结构中构造一个环”，他就使用一种特殊的赋值语句 （语法是临时设计），比如：

    (<= node.next ls.head)

根据我跟一个编译器工程师的讨论，Objective-C 的自动引用计数（ARC）是相当高效的，然而 这种自动引用计数方法是否能满足实时系统要求，还有待实践考验。也许有一天我会再次考虑使用 GC 或者其他方式，但它应该只需要程序员做非常少的工作。


#### 使用 Partial Evaluation 来统一整个编译器的设计

<a href="http://www.itu.dk/~sestoft/pebook/pebook.html">Partial Evaluation</a> 是 Neil Jones 在 80 年代提出的一种自动生成编译器的方法。在 Chez Scheme 里面有一个优化过程叫做 CP0，是一个 online partial evaluation。在 Kent 的另一个课程，我们实现了 CP0 的算法。

然而这种 online partial evaluation，其实可以被作为很多要素的实现方式。除了做 constant propagation, copy propagation 等优化以外，它还可以用于优化掉多余的动态类型检查。这样我就从中得到了一种可以实现动静态类型检查“自动划分”的方法。

再加上从静态分析领域得到的启发，我就得到了以下的类型系统。这个类型系统，也就是 One 语言不同于所有其他语言的特色。


#### 强大，灵活而简单的类型系统

One 语言采用一种我正在设计的非常强大的类型系统。它合并了多种类型系统的最好的部分（Hindley-Milner, intersection type, dependent types ……），但却又不是简单的把它们堆放在一起。这种类型系统给程序员一种“连续性”的强度选择，从完全的动态检查，一直到最严格的定理证明方式（完全确保算法的正确性）。程序员可以完全不写类型，也可以选择只写某些类型。这给编程带来很大的灵活性，实现起来却又很简单。


程序员可以写完全不带类型的函数：

    (def id (x) x)

他没有给参数 x 类型标记，所以类型系统自动的认为 x 可以是“任何对象”。由于函数直接返回了参数 x，而没有针对它的类型进行“操作”，所以这个函数可以通过类型检查。这样就构造出完全“多态”的函数，可以接受任何对象作为参数。


进一小步，程序员也可以声明参数的“简单类型”，这就像普通的语言比如 C 或者 Java 一样。然而跟很多语言不同的是，类型的标记不是放在参数列表上，而是放在函数内部，就像一个普通的 assertion。比如：

    (def id-int (x)
      (: x int)
      x)

这里的 ":" 表示一种“子类型关系”。(: x int) 表示：从现在开始，x 必须是整数，或者是整数的“子类型”，也就是说它必须是一种“可以被当成是整数的对象”。

跟大部分基于 HM 系统的函数式语言（ML，Haskell）不同，One 语言只有一种类型间的关系：子类型。子类型关系表示了类型间的“兼容性”(compatibility)。子类型关系是一种更加灵活的关系，就像“子集合”关系。如果 (: A B)，那么 A 和 B 可以是“等价”的，也有可能 B “真包含”A，也就是说“有某些 B 的成员不是 A”。


更近一步，程序员可以声明更加细节的“需求”，比如：

    (def bar (x)
      (and (: x int) (< x 5))
      x)

这就是说，x 是整数，而且必须小于5。这样 bar 的调用者就有“责任”证明这个事实。它的代码也许像这个样子：

    (def call-bar (y)
      (cond
        [(< y 4)
         (bar y)]
         ...))

注意，call-bar 其实什么事也没做，然而系统能够自动从条件 (< y 4) 得知 (< y 5) 肯定也成立，从而知道 (bar y) 是可以安全调用的。

这种类型的工作方式是几乎所有语言都还没有的。它来自于我对静态分析系统的理解。它可以让程序员对函数的调用者提出相当复杂的需求。这种需求有点像 dependent type，但是它更加实用，用起来也更加容易。


类型标记间的依赖关系

可以选择不写类型并不是说程序可能由于程序员的疏忽，没写类型而导致运行时错误。类型系统在类型标记的“数据流”中，存在一种严格的逻辑依赖关系。比如，如果你写这样一个函数：

    (def foo (y)
      (id-int y))

编译器会拒绝这个程序，因为 id-int 被声明为只接受 int 类型，而它的调用者 foo 却没能在调用它之前“证明”y是一个 int。

注意这里我使用了“证明”这个词。这是因为每一个像 (: x int) 这样的“类型声明”，其实是一个“证明请求”。它的意思是“调用我的人必须事先向我证明，x 的值肯定是一个整数”。

然而 foo 却不能保证 y 是一个整数，因为它自己没有“请求证明”y 是一个整数。这时候，foo 的作者可以加一个请求证明：

    (def foo (y)
      (: y int)
      (id-int y))

这样程序就能通过编译。证明 id-int 的参数是整数的责任，就被“转嫁”到了 foo 的调用者。这样就形成了一种逻辑的“依赖关系链”。

这些逻辑有可能叠加组合起来，形成比较复杂的逻辑表达式。这样调用函数的人，就有责任做两件事情之一：1）直接证明这个“定理” 2）请求自己的调用者证明这个定理。

显然对于复杂的定理，有可能目前还没有人把它证明出来（如哥德巴赫猜想），或者证明它需要很长的时间。这时候程序员为了短期的目标，可以“显式”的声明：我没法证明这个定理。比如：

    (def gold (x)
      (goldbach-conjecture x)
      x)

    (def bar (z)
      (assume (goldbach-conjecture z))
      (gold z))

这个 (assume (goldbach-conjecture)) 告诉编译器：“我没法证明哥德巴赫猜想”。这样编译生成的代码会自动在 (assume (goldbach-conjecture z)) 处插入动态检查。这样如果运行时输入的参数 z 不满足哥德巴赫猜想，程序就会发生运行时错误当掉。当然，你也许能因此拿到 Fields Medal（因为你证明了哥德巴赫猜想不成立），也有可能因此而丧生（因为这程序是你坐的宇宙飞船的自动着陆系统）。


#### 并行和分布式计算

One 语言可以极其简单的实现并行计算，这与 C# 的 async/wait 有点类似，但是它的设计目标是让这种原语成为唯一的并行操作原语，从而让并行计算变得极其容易实现。我们提供一个关键字叫 par，用于指定某段代码可以并行执行。比如你可以说：

    (: x (par (long-computation)))
    (: y x)
    (do-other-things)
    (foo (wait y))

这里的 par 表示：(long-computation) 就会被自动安排为异步执行。

第二行的 y 能够直接得到 x 的“可能还没计算的值”。由于还没有人使用 y 的值，我们并不需要检查 (long-computation) 是否已经执行完毕。所以 (: y x) 和 (do-other-things) 可以毫无停顿的进行。这样 (long-computation) 就和 (: y x) ... (do-other-things) 成为了两个独立的“线程”。

直到必须使用 y 的值，我们才用 wait 去检查“y 计算出来了吗？”，因为 y 其实就是 x，随之引起连锁的问题：“x 计算出来了吗？”如果 x 还没计算完毕，那么就会等待它计算完才会调用 foo。

为什么 par 和 wait 需要显式声明，而不能对程序员透明呢？这是来源于现实系统的限制。我们不能让编译器自动的插入 par 来并行执行某段代码，因为我们不知道 (long-computation) 到底会计算多久。也许它只是一个简单的加法呢？如果我们把这么微小的操作分配给另一个处理器，我们就增加了处理器间通信的开销。然而要想知道一段代码的运行时间，却是一个不可计算的问题。所以我们不得以，必须要求程序员来指定那段代码运行时间足够长，值得进行并行计算。

那么为什么要使用 wait，而不能直接调用 (foo y) 呢？因为问像“x 执行完了吗”这样的问题是需要时间的。任何地方的 par 语句都可能产生“还没计算完的值”，它们会“流”到代码的任意位置。如果我们不能准确的定位它们可能出现的位置，我们就必须在使用每个变量之前问这个问题：“你计算出来了吗？”反复的问，这样就带来了程序效率的大幅度降低。这与我之前谈到的“<a href="http://www.yinwang.org/blog-cn/2013/04/01/lazy-evaluation">惰性求值</a>”的缺点类似。然而，想要基本准确的定位这些 wait 的位置，需要全局流分析，这在要求速度很快，或者需要模块化的编译器里是不大可行的。


以上就是我能想到的 One 语言里比较有特色的地方。具体的设计和实现，还有待多方面的调查和讨论才能最后决定。关于 Neo 操作系统的设计，可以参考我以前的一篇<a href="http://www.yinwang.org/blog-cn/2013/04/14/os-design">博文</a>。
