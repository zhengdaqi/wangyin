---
layout: default
title: 什么是“为什么”
---


1. 我在 Cornell 的时候经常遇到这样的问题，那就是教授们一上课就在黑板上写长篇的“定理证明”，全体同学认认真真在下面抄笔记，就连只有十来个人的小课也是那样。有些写字速度慢的人就不得不带上小型录音机，把教授的课全都录下来，要不就是之后去借别人的笔记来抄。


2. 有一次，某 Cornell 知名教授照着讲义，背对学生，在黑板上写了大半节课，写下好几板的证明，证明的是 simply typed lambda calculus （STLC）的 strong normalization 特性（SN）。刚写完就到下课时间了，他回过头来看着我们喘了一口气，说：“Any questions？”没有人啃声，于是他说：“很好！下课！”

   几天后我问他，你证明了 STLC 有这个特性，然而你却没有告诉我们它“为什么”有这个特性。他神气的看了我一眼：“你不懂吗？”我说：“这个证明我看懂了大部分。可是你没有告诉我它‘为什么’有这个特性。我的意思是，一个东西并不是因为你的证明才具有如此的性质。这性质是它天生就有的，不管你是否能证明它。我想知道的是它为什么有这个性质，以及怎么才能从无到有想出这个证明。”他说：“你问这样的问题有什么意义吗？你需要非常聪明，并且需要经过大量的努力才能想出这样的证明。”


3.  两年之后，我在 Indiana 上了另外一堂程序语言理论课。教授是我之前的导师 Amr     Sabry。他上课从来不带讲义，貌似也没有准备，却每次都能讲清楚问题的关键。

    于是有一天他也开始讲 STLC 的 SN 特性。他说，我不想写下这个证明让你们抄，我只告诉你们大概怎么去想。SN 的意思就是程序肯定会‘终止’。所有会终止的问题，都会有一个“特征值”会随着程序的运行而减小。你需要做的就是找到这个随着 STLC 的运行而缩小的“特征值”是什么。接着他就开始在黑板上画一个图，而不是写下一个公式……


4. 有一次 Cornell 操作系统考试，出了这么一道题：一条河的两边各有5只猴子要过河。可是河上只有一根绳子，猴子需要攀着绳子过河。如果两只猴子在绳子中间遇上了，就会掉进河里。请你使用 semaphore 写出一个程序可以让这些猴子都可以安全过河。

   我的答案是：让这些猴子先去“拿号”，然后被叫到号码的猴子挨个过河。可是没想到这么喜欢排队的美国人，居然觉得我的答案是错的，就因为我没用 semaphore。

   操作系统的课程和书籍往往有很多类似的“同步”问题。对于这些问题，往往有人给你一个“标准答案”，却从来不告诉你这标准答案是怎么想出来的。谁也不知道如何才能“系统的”（systematically），按部就班的得到这些问题的答案。这些问题的“标准答案”里面往往含有一些“聪明技巧”，貌似天上掉下来的。然而，你却很难相信它们是正确的。证明这些答案的正确性，到现在还是研究性质的问题。所以有时候你绞尽脑汁用 semaphore 这样的东西写出来一个程序，试了好多个例子貌似都是对的，结果最后实际运行的时候，遇到前所未有的数据就出问题。

   我觉得这里的问题在于，这些操作系统的“原语”（比如 semaphore） 本来是被“发明”出来解决某个“特定”的问题，而并不是本质上“通用”的东西。对于当时要解决的那一个问题，它也许是很有效的。可是接下来它就被滥用了，被用在了设计者没有考虑过的地方。当然，你就遇到各种麻烦的问题，比如“竞争”，“死锁”。

   这就像很多人在 C 程序里写 macro 用来代替“重复的代码”。在某个程序里这个 macro 也许是有效的。可是接下来它就被滥用了。人们看不到，其实被这个 macro “组合”起来的操作，如果被分开来用，会让程序更加直接的达到目的。然而写出了这个 macro 之后，你就开始错误的认为这些被它所压缩在一起的操作是一个“原语”，从而不假思索的开始“重用”它。这个错误跟 semaphore 被到处滥用的现象，其实本质是一样的。


计算机科学里面遇到的很多难题，其实都是来自于同一个错误：使用错误的工具，解决错误的问题。所以遇到任何这些问题，我们都应该多问几个“为什么”。找准了问题的源头，才能得到最有效的解决方案。
